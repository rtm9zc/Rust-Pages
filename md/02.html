<!DOCTYPE HTML>
<html lang="en-US" manifest="../manifest.appcache">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>Starting to Corrode: Pointers, Memory, Strings, and I/O | Introduction to Rust: From HelloWorld to MapReduce in Four Steps</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="rtm9zc">
        <meta name="description" content="RustLogoRust, in the words of the developers, is a &quot;systems programming language that runs blazingly fast, prevents almost all crashes, and eliminates data races.&quot; These characteristics make it well suited for developing large, concurrent, performance-critical systems that are so prevelant in today&#39;s computing world.">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="../md/02/1.html" />
        
        
        <link rel="prev" href="../md/01/7.html" />
        

        <meta property="og:title" content="Starting to Corrode: Pointers, Memory, Strings, and I/O | Introduction to Rust: From HelloWorld to MapReduce in Four Steps">
        <meta property="og:site_name" content="Introduction to Rust: From HelloWorld to MapReduce in Four Steps">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/rtm9zc">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    </head>
    <body>
        

        <link rel="stylesheet" href="../gitbook/style.css">
        


        
    <div class="book" data-github="rtm9zc/Rust-Pages" data-level="2" data-basepath=".." data-revision="1402427048535">
    <div class="book-header">
    <!-- Actions Left -->
    
    <a href="https://github.com/rtm9zc/Rust-Pages" target="_blank" class="btn pull-left home-bookmark" aria-label="GitHub home"><i class="fa fa-bookmark-o"></i></a>
    
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    <span id="font-settings-wrapper">
        <a href="#" class="btn pull-left toggle-font-settings" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="btn-group btn-block">
        <button id="reduce-font-size" class="btn btn-default">A</button>
        <button id="enlarge-font-size" class="btn btn-default">A</button>
    </div>

    <ul class="list-group font-family-list">
        <li class="list-group-item" data-font="0">Serif</li>
        <li class="list-group-item" data-font="1">Sans</li>
    </ul>

    <div class="btn-group btn-group-xs btn-block color-theme-list">
        <button type="button" class="btn btn-default" id="color-theme-preview-0" data-theme="0">White</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-1" data-theme="1">Sepia</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-2" data-theme="2">Night</button>
    </div>
</div>

    </span>

    <!-- Actions Right -->
    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    

    
    <a href="https://github.com/rtm9zc/Rust-Pages/stargazers" target="_blank" class="btn pull-right count-star hidden-xs"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/rtm9zc/Rust-Pages/watchers" target="_blank" class="btn pull-right count-watch hidden-xs"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>
    

    <!-- Title -->
    <h1>
        <i class="fa fa-spinner fa-spin"></i>
        <a href="../" >Introduction to Rust: From HelloWorld to MapReduce in Four Steps</a>
    </h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        <li>
            <a href="https://github.com/rtm9zc" target="blank" class="author-link">About the author</a>
        </li>
        

        
        <li>
            <a href="https://github.com/rtm9zc/Rust-Pages/issues" target="blank"class="issues-link">Questions and Issues</a>
        </li>
        

        
        <li>
            <a href="https://github.com/rtm9zc/Rust-Pages/edit/master/md/02.md" target="blank" class="contribute-link">Edit and Contribute</a>
        </li>
        

        

        <li data-level="0" data-path="index.html">
            <a href="../"><i class="fa fa-check"></i> Introduction</a>
        </li>
        
            <li class="chapter " data-level="1" data-path="md/01.html">
                
                <a href="../md/01.html">
                    <i class="fa fa-check"></i> <b>1.</b> Getting Started
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="1.1" data-path="md/01/1.html">
                            
                            <a href="../md/01/1.html">
                                <i class="fa fa-check"></i> <b>1.1.</b> Variables
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.2" data-path="md/01/2.html">
                            
                            <a href="../md/01/2.html">
                                <i class="fa fa-check"></i> <b>1.2.</b> Conditionals
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.3" data-path="md/01/3.html">
                            
                            <a href="../md/01/3.html">
                                <i class="fa fa-check"></i> <b>1.3.</b> Pattern Matching
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.4" data-path="md/01/4.html">
                            
                            <a href="../md/01/4.html">
                                <i class="fa fa-check"></i> <b>1.4.</b> Looping
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.5" data-path="md/01/5.html">
                            
                            <a href="../md/01/5.html">
                                <i class="fa fa-check"></i> <b>1.5.</b> Expressions
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.6" data-path="md/01/6.html">
                            
                            <a href="../md/01/6.html">
                                <i class="fa fa-check"></i> <b>1.6.</b> Functions
                            </a>
                            
                        </li>
                    
                        <li  data-level="1.7" data-path="md/01/7.html">
                            
                            <a href="../md/01/7.html">
                                <i class="fa fa-check"></i> <b>1.7.</b> Program 1: Collatz
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li class="chapter " data-level="2" data-path="md/02.html">
                
                <a href="../md/02.html">
                    <i class="fa fa-check"></i> <b>2.</b> Starting to Corrode: Pointers, Memory, Strings, and I/O
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="2.1" data-path="md/02/1.html">
                            
                            <a href="../md/02/1.html">
                                <i class="fa fa-check"></i> <b>2.1.</b> Memory Management and Pointers
                            </a>
                            
                        </li>
                    
                        <li  data-level="2.2" data-path="md/02/2.html">
                            
                            <a href="../md/02/2.html">
                                <i class="fa fa-check"></i> <b>2.2.</b> Vectors and Strings
                            </a>
                            
                        </li>
                    
                        <li  data-level="2.3" data-path="md/02/3.html">
                            
                            <a href="../md/02/3.html">
                                <i class="fa fa-check"></i> <b>2.3.</b> Error Handling
                            </a>
                            
                        </li>
                    
                        <li  data-level="2.4" data-path="md/02/4.html">
                            
                            <a href="../md/02/4.html">
                                <i class="fa fa-check"></i> <b>2.4.</b> Basic I/O
                            </a>
                            
                        </li>
                    
                        <li  data-level="2.5" data-path="md/02/5.html">
                            
                            <a href="../md/02/5.html">
                                <i class="fa fa-check"></i> <b>2.5.</b> Example: Secret Sharing
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li class="chapter " data-level="3" data-path="md/03.html">
                
                <a href="../md/03.html">
                    <i class="fa fa-check"></i> <b>3.</b> Multi-Purpose Maps: Structures, Traits, and Higher-Order Functions
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="3.1" data-path="md/03/1.html">
                            
                            <a href="../md/03/1.html">
                                <i class="fa fa-check"></i> <b>3.1.</b> Structures
                            </a>
                            
                        </li>
                    
                        <li  data-level="3.2" data-path="md/03/2.html">
                            
                            <a href="../md/03/2.html">
                                <i class="fa fa-check"></i> <b>3.2.</b> Traits
                            </a>
                            
                        </li>
                    
                        <li  data-level="3.3" data-path="md/03/3.html">
                            
                            <a href="../md/03/3.html">
                                <i class="fa fa-check"></i> <b>3.3.</b> Higher-Order Functions
                            </a>
                            
                        </li>
                    
                        <li  data-level="3.4" data-path="md/03/4.html">
                            
                            <a href="../md/03/4.html">
                                <i class="fa fa-check"></i> <b>3.4.</b> Example: Mapping a List
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li class="chapter " data-level="4" data-path="md/04.html">
                
                <a href="../md/04.html">
                    <i class="fa fa-check"></i> <b>4.</b> Tasks and Communication
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="4.1" data-path="md/04/1.html">
                            
                            <a href="../md/04/1.html">
                                <i class="fa fa-check"></i> <b>4.1.</b> Task Properties
                            </a>
                            
                        </li>
                    
                        <li  data-level="4.2" data-path="md/04/2.html">
                            
                            <a href="../md/04/2.html">
                                <i class="fa fa-check"></i> <b>4.2.</b> Example: Multi-Tasking Map
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li class="chapter " data-level="5" data-path="md/05.html">
                
                <a href="../md/05.html">
                    <i class="fa fa-check"></i> <b>5.</b> Concurrency Across Tasks: Arcs and Mutexes
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="5.1" data-path="md/05/1.html">
                            
                            <a href="../md/05/1.html">
                                <i class="fa fa-check"></i> <b>5.1.</b> The Arc Module
                            </a>
                            
                        </li>
                    
                        <li  data-level="5.2" data-path="md/05/2.html">
                            
                            <a href="../md/05/2.html">
                                <i class="fa fa-check"></i> <b>5.2.</b> Using a Mutex
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        
            <li class="chapter " data-level="6" data-path="md/06.html">
                
                <a href="../md/06.html">
                    <i class="fa fa-check"></i> <b>6.</b> MapReduce in Rust
                </a>
                
                
                <ul class="articles">
                    
                        <li  data-level="6.1" data-path="md/06/1.html">
                            
                            <a href="../md/06/1.html">
                                <i class="fa fa-check"></i> <b>6.1.</b> Using mapreduce
                            </a>
                            
                        </li>
                    
                </ul>
                
            </li>
        

        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Generated using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 33.333333333333336%;min-width: 29.62962962962963%;"></div>
    </div>
    <div class="chapters">
    
        <a href="../index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="../md/01.html" title="Getting Started" class="chapter done new-chapter" data-progress="1" style="left: 3.7037037037037037%;"></a>
    
        <a href="../md/01/1.html" title="Variables" class="chapter done " data-progress="1.1" style="left: 7.407407407407407%;"></a>
    
        <a href="../md/01/2.html" title="Conditionals" class="chapter done " data-progress="1.2" style="left: 11.11111111111111%;"></a>
    
        <a href="../md/01/3.html" title="Pattern Matching" class="chapter done " data-progress="1.3" style="left: 14.814814814814815%;"></a>
    
        <a href="../md/01/4.html" title="Looping" class="chapter done " data-progress="1.4" style="left: 18.51851851851852%;"></a>
    
        <a href="../md/01/5.html" title="Expressions" class="chapter done " data-progress="1.5" style="left: 22.22222222222222%;"></a>
    
        <a href="../md/01/6.html" title="Functions" class="chapter done " data-progress="1.6" style="left: 25.925925925925927%;"></a>
    
        <a href="../md/01/7.html" title="Program 1: Collatz" class="chapter done " data-progress="1.7" style="left: 29.62962962962963%;"></a>
    
        <a href="../md/02.html" title="Starting to Corrode: Pointers, Memory, Strings, and I/O" class="chapter done new-chapter" data-progress="2" style="left: 33.333333333333336%;"></a>
    
        <a href="../md/02/1.html" title="Memory Management and Pointers" class="chapter  " data-progress="2.1" style="left: 37.03703703703704%;"></a>
    
        <a href="../md/02/2.html" title="Vectors and Strings" class="chapter  " data-progress="2.2" style="left: 40.74074074074074%;"></a>
    
        <a href="../md/02/3.html" title="Error Handling" class="chapter  " data-progress="2.3" style="left: 44.44444444444444%;"></a>
    
        <a href="../md/02/4.html" title="Basic I/O" class="chapter  " data-progress="2.4" style="left: 48.148148148148145%;"></a>
    
        <a href="../md/02/5.html" title="Example: Secret Sharing" class="chapter  " data-progress="2.5" style="left: 51.851851851851855%;"></a>
    
        <a href="../md/03.html" title="Multi-Purpose Maps: Structures, Traits, and Higher-Order Functions" class="chapter  new-chapter" data-progress="3" style="left: 55.55555555555556%;"></a>
    
        <a href="../md/03/1.html" title="Structures" class="chapter  " data-progress="3.1" style="left: 59.25925925925926%;"></a>
    
        <a href="../md/03/2.html" title="Traits" class="chapter  " data-progress="3.2" style="left: 62.96296296296296%;"></a>
    
        <a href="../md/03/3.html" title="Higher-Order Functions" class="chapter  " data-progress="3.3" style="left: 66.66666666666667%;"></a>
    
        <a href="../md/03/4.html" title="Example: Mapping a List" class="chapter  " data-progress="3.4" style="left: 70.37037037037037%;"></a>
    
        <a href="../md/04.html" title="Tasks and Communication" class="chapter  new-chapter" data-progress="4" style="left: 74.07407407407408%;"></a>
    
        <a href="../md/04/1.html" title="Task Properties" class="chapter  " data-progress="4.1" style="left: 77.77777777777777%;"></a>
    
        <a href="../md/04/2.html" title="Example: Multi-Tasking Map" class="chapter  " data-progress="4.2" style="left: 81.48148148148148%;"></a>
    
        <a href="../md/05.html" title="Concurrency Across Tasks: Arcs and Mutexes" class="chapter  new-chapter" data-progress="5" style="left: 85.18518518518519%;"></a>
    
        <a href="../md/05/1.html" title="The Arc Module" class="chapter  " data-progress="5.1" style="left: 88.88888888888889%;"></a>
    
        <a href="../md/05/2.html" title="Using a Mutex" class="chapter  " data-progress="5.2" style="left: 92.5925925925926%;"></a>
    
        <a href="../md/06.html" title="MapReduce in Rust" class="chapter  new-chapter" data-progress="6" style="left: 96.29629629629629%;"></a>
    
        <a href="../md/06/1.html" title="Using mapreduce" class="chapter  " data-progress="6.1" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_17">
                    
                        <h1 id="starting-to-corrode-pointers-memory-strings-and-i-o">Starting to Corrode: Pointers, Memory, Strings, and I/O</h1>
<p>This section of the tutorial introduces one of the &quot;rustiest&quot; aspects of Rust: memory management.  </p>
<p>Rust provides memory references in a way that is quite different from other languages you may be familiar with, and it requires some effort to understand, but provide the big advantage of providing both explicit control and safety. We&#39;ll also cover strings and vectors, file and user I/O, and basic error handling in Rust. At the end of this section, you&#39;ll write a simple encryption program that employs many of the new concepts.</p>
<h2 id="memory-management-and-pointers">Memory Management and Pointers</h2>
<h3 id="boxes">Boxes</h3>
<p>The <em>box</em> in Rust is the fundamental abstraction of memory. References in Rust can point to boxes.  Because Rust is designed to emphasize safety, any allocated memory in Rust is <em>boxed</em>, and thus any box can be thought of as simply a chunk of memory. </p>
<h3 id="pointer-types">Pointer Types</h3>
<p>Rust provides two main pointer types: the <em>owned</em> pointer (indicated by the tilde: <code>~</code>) and the <em>borrowed</em> reference (denoted with ampersand: <code>&amp;</code>). Both kinds of pointers point to a box, and the pointer types are in line with the type of data the box contains. For example, <code>~[&amp;str]</code> is a owned reference to a vector of borrowed strings.</p>
<p>Similarly to C or C++, dereferencing a Rust pointer is done with the star operator (<code>*</code>). The next section on ownership will go into more detail on the usage and interaction of both of these.</p>
<div class="note">
Note: Legacy Rust code (before 0.9) also has a &quot;managed pointer&quot; represented by the <code>@</code> which was automatically managed (garbage collected). As of Rust 0.9, this syntax is deprecated, however it is planned to be reintroduced in future releases. These added a deal of simplicity to pointer management, however other pointer types could be used with more efficency.  Automatically managed pointers may be implemented as library types.
</div>

<h3 id="ownership">Ownership</h3>
<p>In Rust, there is a notion of <em>ownership</em> of an object.  The owner of an object, which could be a variable that refers to that object, manages the object&#39;s lifetime (that is, when its memory is allocated and reclaimed).  Programmers do not have to explicitly allocate and deallocate storage.  Rather, it is done by the Rust compiler and runtime enviroment based on how the object references are used.</p>
<h4 id="owned-boxes">Owned Boxes</h4>
<p>A declaration of an owned (<code>~</code>) pointer can be thought of as giving the declared variable ownership of the box.  What does this mean in code? The following block works as anticipated, printing out &quot;10&quot;.</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> x = ~<span class="hljs-number">10</span>;
    println!(<span class="hljs-string">"{:d}"</span>, *x);
</code></pre>
<p>However the following block gives a compilation error:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> x = ~<span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> y = x;
    println!(<span class="hljs-string">"{:d}"</span>, *x);
</code></pre>
<pre><code>tut2.rs:3:23: 3:24 <span style="color:red;">error:</span> use of moved value: `x`
tut2.rs:3     println!("{:d}", *x);
</code></pre>

<p>The error message is a bit unclear, but what it is reporting is a violation of ownership rules.  When we create the owned box of <code>~10</code>, that box is owned by the variable <code>x</code>. The initialization, <code>let y = x;</code> assigns the <em>pointer</em> to y. Because of Rust&#39;s emphasis on safety this is not allowed: it creates two references to an owned box.  </p>
<p>In other languages, such as C and Java, there are no restrictions on pointer sharing.  We could do the following:</p>
<pre><code class="lang-c">    <span class="hljs-comment">//This assignment works in C, not Rust!</span>
    y = x;
    *y = <span class="hljs-number">3</span>;
</code></pre>
<p>This changes the value of <code>*x</code> through the alias.  With Rust, the assignment, <code>y = x</code> transfers ownership of the box <code>x</code> refers to from the <code>x</code> reference to the <code>y</code> reference. From this point on, any attempts to use <code>x</code> to manipulate that box will result in a compilation error.</p>
<p>We can make a copy of a box using the <code>clone()</code> method which copies over the content of a box and creates a new owned pointer to the copy. So the following code will assign <code>y</code> to a new owned pointer pointing to a new copy of the value &quot;10&quot;. The dereferencing of <code>x</code> no longer causes a compiler error, as <code>x</code> still has proper ownership of its box.</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> x = ~<span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> y = x.clone();
    println!(<span class="hljs-string">"{:d}"</span>, *x);
</code></pre>
<p>Keep in mind though, since <code>x</code> and <code>y</code> refer to different boxes now, so a modification of <code>*x</code> will not be visible through <code>y</code>.</p>
<h4 id="borrowed-references">Borrowed References</h4>
<p>As we have seen, to use a box in multiple instances with the <code>~</code> owned pointers, we need to create copies of the box. Also, we can&#39;t access the same box with multiple variables. If we were to exclusively use owned pointers, the copying would be very expensive, and eliminate the benefits of data sharing for uses like pass-by-reference and data structures.  Rust&#39;s solution is to provide a way for box owners to loan out their objects.  </p>
<p>Using the <code>&amp;</code> operator creates a temporary reference to some memory that has already been allocated. These references are refered to as &quot;borrowed&quot; because they can access the contents of the box during the borrowing period, but do not own the box. This most commonly used to pass in a pointer reference to a method.</p>
<p>Because of Rust&#39;s emphasis on safety there are many resctriction on what can be done with a reference. Most notably, if a pointer has a borrowed reference in scope (more on scope in the next section), any function which would free the memory or change the type being pointed to would cause a compile-time error. Think of it this way: creating a reference to a box &quot;lends&quot; that box&#39;s contents to the reference until the loaned box is &quot;returned&quot;.  Thus, a reference owner gives up full control over a loaned box while it is being borrowed.</p>
<p>Borrowed references are frequently used as function parameters.  For example,</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">borrow</span>(</span>r : &amp;<span class="hljs-keyword">int</span>) -&gt; <span class="hljs-keyword">int</span> {
    *r
}
</code></pre>
<p>declares the function <code>borrow(&amp;int)</code> to take a borrowed pointer to an int.  We can call it by passing in an owned pointer:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = box <span class="hljs-number">10</span>;
    println!(<span class="hljs-string">"borrow(x): {:d}"</span>, borrow(x));
</code></pre>
<p>Borrowed pointers can also be loaned by the borrowee, within the lifetime of the original loan.  We can pass in an owned pointer to borrow2, which borrows that pointer and passes it as a borrowed pointer to borrow:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">borrow2</span>(</span>r : &amp;<span class="hljs-keyword">int</span>) -&gt; <span class="hljs-keyword">int</span> {
   borrow(r)
}
</code></pre>
<h4 id="pointer-mutability">Pointer Mutability</h4>
<p>As with scalar variables, boxes are immutable by default. The <code>mut</code> qualifier is used to indicate that a box is mutable.  Mutability applies to the <em>contents</em> of a box, and not the pointer itself.</p>
<p>For example,</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">increment</span>(</span>r: &amp;<span class="hljs-keyword">int</span>) {
    *r = *r + <span class="hljs-number">1</span>;
}
</code></pre>
<p>is not permitted and returns the following compilation error:</p>
<pre><code>
borrowed.rs:2:4: 2:6 <span style="color:red;">error:</span> cannot assign to immutable dereference of & pointer
borrowed.rs:2     *r = *r + 1;
                   ^~
</code></pre>

<p>To allow the modification, we need to declare the parameter as a borrowed, mutable reference: <code>r: &amp;mut int</code></p>
<p>Now, if we try to pass in a nonmutable reference as the parameter, we will receive a different error. The following code:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> x = ~<span class="hljs-number">10</span>
    increment(x)
</code></pre>
<p>Produces the following error:</p>
<pre><code>
borrowed.rs:16:14: 16:15 <span style="color:red;">error:</span> cannot borrow immutable dereference of ~ pointer as mutable
borrowed.rs:16     increment(x);
</code></pre>

<p>To change this, we need to add <code>mut</code> to the declaration:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = box <span class="hljs-number">10</span>;
    increment(x);
</code></pre>
<p>The <code>mut</code> here applies to the reference <code>x</code> and is also inherited by the box (so no separate <code>mut</code> annotation is needed for the <code>~</code>.  It allows both the variable <code>x</code> to be reassigned, as well as the contents of the owned box to be modified:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = ~<span class="hljs-number">10</span>;
    x = ~<span class="hljs-number">20</span>;
    *x = <span class="hljs-number">30</span>;
</code></pre>
<p>The first assignment statement creates a new box owned by <code>x</code> holding the value <code>20</code>. The second assignment statement modifies the value in that box to be <code>30</code>.  Without the <code>mut</code>, neither assignment would be permitted by the Rust compiler.</p>
<p>Borrowed references do not inherit mutability.  For example, this code is invalid:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> val1 = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> val2 = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> borrowed = &amp;val1;
    borrowed = &amp;val2;
    *borrowed = <span class="hljs-number">11</span>;
</code></pre>
<pre><code>
borrowed.rs:23:4: 23:13 <span style="color:red;">error:</span> cannot assign to immutable dereference of & pointer
borrowed.rs:23     *borrowed = 11;
                   <span style="color:red;">^~~~~~~~~</span>
</code></pre>

<p>To allow both modifications, we need the following:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> borrowed = &amp;<span class="hljs-keyword">mut</span> val1;
</code></pre>
<p>This allows both modifying the referenced box and changing what <code>borrowed</code> references. </p>
<p>Keep in mind that references are type checked (yet another safety measure of Rust!) so the following code produces an error at compile time due to trying to reassign an int reference to a float reference.</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> val1 = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> val3 = <span class="hljs-number">10.0</span>;
    <span class="hljs-keyword">let</span> borrowed = &amp;val1;
    borrowed = &amp;val3;
</code></pre>
<pre><code>tut2.rs:4:16: 6:21 <span style="color:red;">error:</span> mismatched types: expected `&&lt;VI0&gt;` but found `&&lt;VF0&gt;` (expected integral variable but found floating-point variable)
tut2.rs:4     borrowed = &val3;
</code></pre>

<h4 id="freezing-objects">Freezing Objects</h4>
<p>When an object is loaned through a borrowed reference, the lender loses the ability to modify that object. This is especially important for
multi-tasking (which we&#39;ll get to soon), but still relevant with a single thread.</p>
<p>For example, the following program produces a compiler error: </p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">10</span>;
    {
        <span class="hljs-keyword">let</span> y = &amp;x;
        x = <span class="hljs-number">11</span>; <span class="hljs-comment">// Error</span>
    }
    x = <span class="hljs-number">12</span>; <span class="hljs-comment">//This is fine</span>
</code></pre>
<pre><code>example.rs:4:9: 4:10 <span style="color:red;">error:</span> cannot assign to `x` because it is borrowed
example.rs:4         x = 11;
</code></pre>

<p>When the reference <code>y</code> borrows the value <code>x</code> refers to, the value of <code>x</code> is frozen until the reference to it goes out of scope. Thus, the first reassignment here is invalid, but the second (after <code>y</code> is out of scope) is fine.</p>
<h3 id="lifetimes">Lifetimes</h3>
<p>Memory allocated in Rust is automatically freed when its owner either goes out of scope or is reassigned. This eliminates the need to explicitly free storage (as in C or C++), but guarantees safety without giving up control to an expensive garbage collector.  </p>
<p>Owned pointers follow similar rules of deallocation, so borrowing a reference to some box and trying to access it once it has gone out of scope throws a compiler error.</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> reference: &amp;~<span class="hljs-keyword">int</span>;
    {
        <span class="hljs-keyword">let</span> val: ~<span class="hljs-keyword">int</span> = ~<span class="hljs-number">10</span>;
        reference = &amp;val;
    } <span class="hljs-comment">//val deallocated here</span>
    println!(<span class="hljs-string">"{:d}"</span>, **reference); <span class="hljs-comment">//Referencing something that's gone!</span>
</code></pre>
<pre><code>example.rs:4:21: 4:25 <span style="color:red;">error:</span> borrowed value does not live long enough
example.rs:4         reference = &val;
</code></pre>

<h2 id="vectors-and-strings">Vectors and Strings</h2>
<p>Rust provides built-in vector and string types, consistent with Rust&#39;s focus on safety.</p>
<h4 id="vectors">Vectors</h4>
<p>A vector is defined by using comma seperated values within brackets. </p>
<p>A specific element can be accessed via <code>foo[index]</code>. The following examples show simple vector functions:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">vec</span> = ~[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
    <span class="hljs-keyword">vec</span>.push(<span class="hljs-number">3</span>); <span class="hljs-comment">// Appends to end: [0, 1, 2, 3]</span>

    <span class="hljs-keyword">vec</span>.insert(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>); 
    <span class="hljs-comment">// Inserts 10 at position 2: [0, 1, 10, 2, 3]</span>

    <span class="hljs-keyword">let</span> last = <span class="hljs-keyword">vec</span>.pop(); 
    <span class="hljs-comment">// Returns last element, removing it from the vector: [0, 1, 10, 2]</span>

    <span class="hljs-keyword">let</span> element1 = <span class="hljs-keyword">vec</span>.remove(<span class="hljs-number">1</span>); 
    <span class="hljs-comment">// Returns and removes element at specified index: [0, 10, 2]</span>

    <span class="hljs-comment">// An iterator for going through all elements in order: </span>
    <span class="hljs-keyword">for</span> &amp;x in <span class="hljs-keyword">vec</span>.iter() { <span class="hljs-comment">// note the use of &amp; for borrowing</span>
        println!(<span class="hljs-string">"{}"</span>, x);
    }

    <span class="hljs-comment">// len() returns the number of elements in the vector</span>
    <span class="hljs-keyword">for</span> i in range(<span class="hljs-number">0</span>, <span class="hljs-keyword">vec</span>.len()) { 
        println!(<span class="hljs-string">"{}"</span>, <span class="hljs-keyword">vec</span>[i]);
    }
</code></pre>
<p>The above includes some of the more useful functions for a <code>Vec</code>, and a more extensive list can be found at <a href="http://static.rust-lang.org/doc/master/std/vec/struct.Vec.html" target="_blank">the official Rust documentation</a></p>
<h4 id="strings">Strings</h4>
<p>Rust supposrts a <code>string</code> type, which is a vector of characters.  Each character is a UTF-8 sequence, represented by the <code>u8</code> type in Rust.</p>
<p>A notable construct that is very important for strings is the <code>slice</code>. This represents a view into a string, but not a string itself. Its type is <code>&amp;string</code>.  </p>
<p>Methods that produce a slice include <code>slice(&amp;self, begin: int, end: int)</code>, which returns a slice of characters between begin and end - 1, <code>slice_from(&amp;self, begin: int)</code>, which returns a slice with first element from the index provided that continues to the end, and <code>slice_to(&amp;self, end: int)</code>, which returns a slice starting at the beginning with final element from index end - 1. </p>
<p>These slice methods each produce an immutable value, so they cannot be modified. </p>
<p>To do something such as taking a substring, a slice may be converted to an owned string via the <code>to_owned(&amp;self)</code> method. These slice methods work on any vector, but string manipulation is the most common use of slices.</p>
<p>Other notable string methods include <code>str::eq(&amp;~str, &amp;~str)</code>, which checks two strings for bytewise equality, and <code>split(&amp;self, char)</code>, which returns an iterator that splits the string the method is called on into slices delimited by the parameter character. </p>
<p>For string concatenation, the <code>+</code> operator is used. </p>
<p>These methods are used in the example below:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> string = ~<span class="hljs-string">"This is a string"</span>;
    <span class="hljs-keyword">let</span> subst1 = string.slice(<span class="hljs-number">10</span>, <span class="hljs-number">16</span>).to_owned();
    <span class="hljs-keyword">let</span> subst2 = string.slice_from(<span class="hljs-number">10</span>).to_owned();
    println!(<span class="hljs-string">"{}"</span>, std::<span class="hljs-keyword">str</span>::eq(&amp;subst1, &amp;subst2));
    <span class="hljs-keyword">let</span> doublesub = subst1 + subst2;
    println!(<span class="hljs-string">"{}"</span>, doublesub);
    <span class="hljs-comment">//Using split iterator to print word by word</span>
    <span class="hljs-keyword">for</span> tempstr in string.split(<span class="hljs-string">' '</span>) {
        println!(<span class="hljs-string">"{}"</span>, tempstr);
    }
    <span class="hljs-comment">//Another useful function of the split iterator</span>
    <span class="hljs-comment">//collect() Creates a vector that = ~["This", "is", "a", "string"]</span>
    <span class="hljs-keyword">let</span> wordvec: ~[&amp;<span class="hljs-keyword">str</span>] = string.split(<span class="hljs-string">' '</span>).collect(); 
    <span class="hljs-keyword">for</span> &amp;s in wordvec.iter() {
        println!(<span class="hljs-string">"{}"</span>, s);
    }
</code></pre>
<p>As with vectors, further documentation on string functions can be found in the <a href="static.rust-lang.org/doc/master/std/str">official Rust documentation</a>.</p>
<h4 id="exercises">Exercises</h4>
<blockquote>
<p><strong>Exercise 2.1.</strong> Implement a function, <code>increment(v: &amp;[int])</code> that takes as input a vector of integers and returns a new vector of integers that has the values of the original list each incremented by one.  For example:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>) {
  <span class="hljs-keyword">let</span> p = ~[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
  <span class="hljs-keyword">let</span> q = increment(p);
  <span class="hljs-keyword">for</span> &amp;x in q.iter() {
     print!(<span class="hljs-string">"{:d} "</span>, x);
  }
}
</code></pre>
<p>should print out 2 3 4.</p>
</blockquote>
<hr>
<blockquote>
<p><strong>Exercise 2.2.</strong>  Implement a function, <code>incrementMut(v: &amp;mut [int])</code>, that takes as input a vector of integers and modifies the values of the original list by incrementing each value by one.  For example:</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>) {
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> p = ~[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
  incrementMut(p);
  <span class="hljs-keyword">for</span> &amp;x in p.iter() {
     print!(<span class="hljs-string">"{:d} "</span>, x);
  }
}
</code></pre>
<p>should print out 2 3 4.  </p>
</blockquote>
<h2 id="error-handling">Error Handling</h2>
<p>Error handling in Rust is done with the intention of catching what can be caught at compile-time, and reducing runtime errors. To accomplish this, Rust has two special types to assist with error handling: the <code>Option&lt;T&gt;</code>, and <code>Result&lt;T,E&gt;</code>. The <code>Option&lt;T&gt;</code> type used for functions which either create an object of type <code>T</code>, or fail (represented by <code>None()</code>). A <code>Result&lt;T,E&gt;</code> is similar to an <code>Option&lt;T&gt;</code>, but the value is determined on whether a function succeds as intended on a pre-existing object (as opposed to the creation of a new object with <code>Option&lt;T&gt;</code>). </p>
<p>An <code>Option</code> or <code>Result</code> requires a match statement to use the values obtained. For an <code>Option</code>, there are two possible outcomes for the value: a successful object creation, represented as <code>Some(T)</code>, or a failure, represented as <code>None</code>. In the branch which specifies <code>Some(T)</code>, <code>T</code> is filled in with a variable of type <code>T</code>. In the event of a failed creation, the <code>fail</code> macro can be used to output an error message upon failure. In the following example, the method <code>File::create(&amp;Path)</code> returns an <code>Option&lt;File&gt;</code>. If the file, foo.txt, doesn&#39;t properly open, the message specified in the macro will be printed upon the exit. If it does, in the <code>Some</code> branch, <code>file</code> refers to the <code>File</code> foo.txt.</p>
<pre><code class="lang-rust">     <span class="hljs-keyword">match</span> File::create(&amp;Path::new(<span class="hljs-string">"foo.txt"</span>)) {
               Some(<span class="hljs-keyword">mut</span> file) =&gt; { <span class="hljs-comment">//File was created successfully!, the variable "file" is the instance of File opened }</span>
               None =&gt; { <span class="hljs-comment">//File failed to open correctly</span>
                         <span class="hljs-keyword">fail</span>!(<span class="hljs-string">"Creating foo.txt failed!"</span>);
             }
     }
</code></pre>
<p>Similar to the <code>Option</code>, a <code>Result</code> must have a match statement called upon it to use the value as well. Instead of <code>Some(T)</code> and <code>None</code>, however, a <code>Result</code> has branches of <code>Ok(T)</code> and <code>Err(E)</code> respectively. In these cases, the <code>Err(E)</code> branch has the value of  <code>E</code> assigned to an error of type <code>E</code>, specified in the function that returns the <code>Result</code>. For example, the <code>read_line(&amp;mut self)</code> function of the <code>io::BufferedReader</code> class (which will be gone over more extensively in the next section in IO) returns a <code>Result&lt;String, IoError&gt;</code>. In the following example, a line is read from stdin using this function, and then matched accordingly. Note how the <code>Err(E)</code> branch requires defining a new variable to represent the error type, as opposed to <code>None</code> in an <code>Option</code>, which has no associated variable returned.</p>
<pre><code class="lang-rust">      <span class="hljs-keyword">let</span> reader = io::stdio::stdin();
      <span class="hljs-keyword">match</span> reader.read_line() {
              Ok(stringRead) =&gt; println!(<span class="hljs-string">"Line read: {}"</span>, stringRead),
            Err(e) =&gt; println!(<span class="hljs-string">"Read failed! Error: {}"</span>, e)
        }
</code></pre>
<h2 id="basic-i-o">Basic I/O</h2>
<p><strong>NOTE: THE EXAMPLES IN THIS SECTION ARE MOSTLY OBSOLETE, CURRENT EXAMPLES ARE PLACEHOLDERS</strong></p>
<p>Rust handles file and user input/output using the <a href="http://static.rust-lang.org/doc/master/std/io/index.html" target="_blank">std::io</a> module. </p>
<p>The most intuitive way to work with reading in stdin and files is through the use of a <a href="http://static.rust-lang.org/doc/master/std/io/struct.BufferedReader.html" target="_blank">BufferedReader</a>, which will be explained more in depth in the following sections. Take note that many methods in <code>BufferedReader</code> return vectors of bytes, not strings, so appropriate conversions may be necessary.</p>
<h3 id="working-with-standard-input-stdin-">Working with Standard Input (stdin)</h3>
<p>Standard input is provided through <code>std::io::stdin</code>, and implemented by creating a buffered reader.  The following example (taken from the Rust documentation) prints out a series of lines from standard input, automatically stopping at the end of input. The <code>lines</code> method returns an iterator that goes through each line until the end of input.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">use</span> std::io::buffered::BufferedReader;
<span class="hljs-keyword">use</span> std::io::stdin;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>){
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stdin = BufferedReader::new(stdin());
    <span class="hljs-keyword">for</span> line in stdin.lines() {
        print(line);
    }
}
</code></pre>
<p>Reading line by line is done using the <code>read_line()</code> function, which was used in an example in the previous section. This is a bit more difficult to implement, as <code>readline()</code> uses an <code>IoResult&lt;String&gt;</code> as it&#39;s output. Using what we learned from the previous section, the example code below reads in the next 5 lines from stdin, and prints them. If there are less than 5 lines, the loop ends without crashing the program.</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stdin = BufferedReader::new(stdin());
    <span class="hljs-keyword">for</span> i in range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>) {
        <span class="hljs-keyword">match</span> stdin.read_line() {
            Some(line) =&gt; {
                print(line);
            }
            None =&gt; {
                println(<span class="hljs-string">"End of input!"</span>);
                <span class="hljs-keyword">break</span>;
            }
        }
    }
</code></pre>
<h3 id="files">Files</h3>
<p>The standard library functions for working with files in Rust are handled via the <a href="http://static.rust-lang.org/doc/master/std/io/fs/struct.File.html" target="_blank">std::io::File</a> module. This module contains methods for opening and writing to a file. </p>
<p>A file is opened using <code>Path</code> objects, which are included in any Rust program by default. Creating a <code>Path</code> object is done through <code>Path::new(&quot;path/to/file.foo&quot;)</code>. </p>
<p>To simply open a new file for writing, <code>File::create(&amp;Path)</code> is the simplest call. This returns an <code>Option&lt;File&gt;</code> type, so it must be matched to ensure that a file was successfully opened. </p>
<p>The two most common ways to write to the file once opened are the following: <code>File::write(&amp;mut self, &amp;[u8])</code>, which writes a buffer of bytes to a file, and <code>File::write_str(&amp;mut self, &amp;str)</code>, which writes a string to the file.</p>
<p>This example demonstrated opening a file for writing using both of these methods:</p>
<pre><code class="lang-rust"><span class="hljs-keyword">use</span> std::io::File;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>)
{
    <span class="hljs-keyword">match</span> File::create(&amp;Path::new(<span class="hljs-string">"message.txt"</span>)) {
        Some(<span class="hljs-keyword">mut</span> file) =&gt; {
            file.write(bytes!(<span class="hljs-string">"line one\n"</span>));
            file.write_str(<span class="hljs-string">"line two\n"</span>);
        }
        None =&gt;{
            println(<span class="hljs-string">"Opening message.txt failed!"</span>);
        }
    }
}
</code></pre>
<p>Reading a file can be accomplished easily through using the <a href="static.rust-lang.org/doc/master/std/io/struct.BufferedReader.html">BufferedReader</a> module, much like reading from standard in. </p>
<p>Opening a file to a <code>BufferedReader</code> is done using the <code>File::open(&amp;Path)</code> function, which opens the file at a given path in read-only mode, followed by <code>BufferedReader::new(File)</code>. </p>
<p>Note that the file needs to be matched before converting to a <code>BufferedReader</code>, as <code>File::open()</code> returns an <code>Option&lt;File&gt;</code> type. Once converted to a <code>BufferedReader</code>, a file is read in an identical manner to reading from stdin in the previous example, and all relevant methods are outlined on the <a href="static.rust-lang.org/doc/master/std/io/struct.BufferedReader.html">BufferedReader</a> documentation.</p>
<p>Here&#39;s a simple example of reading a file:</p>
<pre><code class="lang-rust">    <span class="hljs-keyword">match</span> File::open(&amp;Path::new(<span class="hljs-string">"message.txt"</span>)) {
        Some(file) =&gt; {
            <span class="hljs-keyword">let</span> reader = BufferedReader::new(file);
            <span class="hljs-comment">//reading from file</span>
        }
        None =&gt;{
            println(<span class="hljs-string">"Opening message.txt failed!"</span>);
        }
    }
</code></pre>
<p>The <code>File::open_mode(&amp;Path, FileMode, FileAccess)</code> method allows specifying the mode in which a file is accessed. <code>FileMode</code> and <code>FileAccess</code> are <em>enumerable types</em> imported from <a href="http://static.rust-lang.org/doc/master/std/io/type.FileMode.html" target="_blank">std::io::FileMode</a> and <a href="http://static.rust-lang.org/doc/master/std/io/type.FileAccess.html" target="_blank">std::io::FileAccess</a> respectively. For example, to open a file with read and write access, positioned to append to the end of the file, the following must be included, and then called as so.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">use</span> std::io::{File, Append, ReadWrite};

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>) {
   <span class="hljs-keyword">let</span> file = File::open_mode(&amp;Path::new(<span class="hljs-string">"message.txt"</span>), Append, ReadWrite);
}
</code></pre>
<p>Like the other file methods, this returns an <code>Option</code> object that must be matched to check for opening failures.</p>
<h2 id="example-secret-sharing">Example: Secret Sharing</h2>
<p>The XOR operation is a simple, but effective method for hiding meaning. It&#39;s derived from the identity <code>A = (A ^ B) ^ B</code>.  XOR-ing a message with a random key provides <em>perfect</em> encryption, known as a <em>one-time pad</em>. It is essentially the only form of encryption
that is information-theoretically secure, but is impractical for most purposes since it requires a perfectly-random key as long as the message and that key can never be reused.</p>
<p>It works by taking in a message and a random bit sequence (key) of equal length. Each bit in the message is XORed with the corresponding bit in the key to produce the encrypted message. The original message can then be recovered by applying the XOR process to the key and the encrypted message.</p>
<p>For this exercise, we will use this strategy to convert a plaintext file into two secret shares, each of which discloses no information about the original file (other than its length), but if someone has both shares they can put them together to produce the original file.  A paranoid individual might use such an approach to store a file in the cloud by storing one share using Dropbox and the other share using Google Docs. The user could acquire both shares to obtain the file, and if the NSA can hypothetically (of course) obtain all of the data from one of the services but not both of them, it would not be enough to learn the contents of the file.</p>
<p>Note that our implementation uses <code>td::rand::random</code> o generate the random key.  This is not cryptographically strong randomness, so should be used for entertainment purposes only!  (If you are interested in better random numbers, see <a href="https://github.com/wbkostan/cs4414-ps4">tRustees: True Random Number Generation</a>.)</p>
<p>We&#39;ll provide the code to do the splitting, and leave it as an exercise for you to write the joining code.</p>
<h3 id="splitter">Splitter</h3>
<p>The following Rust code implements the splitter. It takes as input the name of a file, and writes out two share files.</p>
<pre><code class="lang-rust"><span class="hljs-keyword">use</span> std::rand::random;
<span class="hljs-keyword">use</span> std::os;
<span class="hljs-keyword">use</span> std::io::File;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span>(</span>) {
    <span class="hljs-keyword">let</span> args: ~[~<span class="hljs-keyword">str</span>] = os::args();
    <span class="hljs-keyword">if</span> args.len() != <span class="hljs-number">2</span> {
        println!(<span class="hljs-string">"Usage: {:s} &lt;inputfile&gt;"</span>, args[<span class="hljs-number">0</span>]); 
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> fname = args[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> path = Path::new(fname.clone());
        <span class="hljs-keyword">let</span> msg_file = File::open(&amp;path);

        <span class="hljs-keyword">match</span> (msg_file) {
            Some(<span class="hljs-keyword">mut</span> msg) =&gt; {
                <span class="hljs-keyword">let</span> msg_bytes: ~[<span class="hljs-keyword">u8</span>] = msg.read_to_end();
                <span class="hljs-keyword">let</span> share1_file 
                       = File::create(&amp;Path::new(fname + <span class="hljs-string">".share1"</span>));
                <span class="hljs-keyword">let</span> share2_file 
                       = File::create(&amp;Path::new(fname + <span class="hljs-string">".share2"</span>));

                <span class="hljs-keyword">match</span> (share1_file, share2_file) {
                    (Some(share1), Some(share2)) =&gt; { 
                        split(msg_bytes, share1, share2); 
                        } ,
                    (<span class="hljs-number">_</span>, <span class="hljs-number">_</span>) =&gt; <span class="hljs-keyword">fail</span>!(<span class="hljs-string">"Error opening output files!"</span>),
                }
            } ,
            None =&gt; <span class="hljs-keyword">fail</span>!(<span class="hljs-string">"Error opening message file: {:s}"</span>, fname)
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">xor</span>(</span>a: &amp;[<span class="hljs-keyword">u8</span>], b: &amp;[<span class="hljs-keyword">u8</span>]) -&gt; ~[<span class="hljs-keyword">u8</span>] {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ret = ~[];
    <span class="hljs-keyword">for</span> i in range(<span class="hljs-number">0</span>, a.len()) {
    ret.push(a[i] ^ b[i]);
    }
    ret
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">split</span>(</span>msg_bytes: &amp;[<span class="hljs-keyword">u8</span>], <span class="hljs-keyword">mut</span> share1: File, <span class="hljs-keyword">mut</span> share2: File) {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> random_bytes: ~[<span class="hljs-keyword">u8</span>] = ~[];
    <span class="hljs-comment">// This is not cryptographically strong randomness! </span>
    <span class="hljs-comment">// (For entertainment purposes only.)</span>
    <span class="hljs-keyword">for</span> <span class="hljs-number">_</span> in range(<span class="hljs-number">0</span>, msg_bytes.len()) {
    <span class="hljs-keyword">let</span> random_byte = random();
    random_bytes.push(random_byte);
    }

    <span class="hljs-keyword">let</span> encrypted_bytes = xor(msg_bytes, random_bytes);
    share1.write(random_bytes);
    share2.write(encrypted_bytes);
}
</code></pre>
<h4 id="joiner">Joiner</h4>
<p>The joiner reverses the splitting process, taking the two shares and combining them to produce the original message.</p>
<blockquote>
<p><strong>Exercise 2.3.</strong> Implement the joiner.  It should take two file names as its inputs, and output to standard output the result of XOR-ing the bytes in those files. The input files must be the same length.</p>
</blockquote>
<p>Your joiner should be able to produce the plaintext from the example
files: <a href="http://rtm9zc.github.io/Rust-Pages/code/msg.share1">msg.share1</a> and <a href="http://rtm9zc.github.io/Rust-Pages/code/msg.share2">msg.share2</a>.  You should download these files (look at them to confirm they appear to be random bytes).  </p>
<p>Then, try executing:</p>
<pre><code>
joiner msg.share1 msg.share2
</code>
</pre>

<p>If you implemented the joiner correctly, you should see a (somewhat) <a href="http://www.gutenberg.org/cache/epub/1518/pg1518.html">meaningful message</a>.</p>
<div class="credits">
This tutorial was created by Alex&nbsp;Lamana, Rob&nbsp;Michaels, Wil&nbsp;Thomason, and David&nbsp;Evans for <a href="http://rust-class.org">University of Virginia cs4414 Spring 2014</a>.
</div>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="../md/01/7.html" class="navigation navigation-prev " aria-label="Previous page: Program 1: Collatz"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../md/02/1.html" class="navigation navigation-next " aria-label="Next page: Memory Management and Pointers"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="../gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="../gitbook/app.js"></script>
        

    
    <script src="../gitbook/plugins/gitbook-plugin-mixpanel/plugin.js"></script>
    

    
    <script src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {};
    gitbook.start(config);
});
</script>

    </body>
</html>
